//
//  MessageCell.swift
//  GPS
//
//  Created by Allen Hsiao on 2020/6/29.
//  Copyright Â© 2020 Allen Hsiao. All rights reserved.
//

import Foundation
import UIKit

class myTableView : UITableView {
    override var intrinsicContentSize: CGSize {
        self.layoutIfNeeded()
        return self.contentSize
    }
    
    override var contentSize: CGSize {
        didSet{
            self.invalidateIntrinsicContentSize()
        }
    }
}

class MessageCellBack: UITableViewCell {
    var sender : String?
    var message : String?
    var date : String?
//    var attachedImages = [UIImage]()
    var imageUrls = [String]()
    weak var viewController : UIViewController?
//    var bottomConstraint: NSLayoutConstraint?

    
    var senderLabel : UILabel = {
        var textLabel = UILabel()
        textLabel.translatesAutoresizingMaskIntoConstraints = false
        textLabel.backgroundColor = .clear
        textLabel.font = UIFont(name: "NotoSansTC-Bold", size: 15)
        textLabel.textColor = MYTLE
        return textLabel
    }()
    
    var messageView : UITextView = {
        var textView = UITextView()
        textView.translatesAutoresizingMaskIntoConstraints = false
//        textView.sizeToFit()
        textView.isScrollEnabled = false
        textView.isEditable = false
        textView.backgroundColor = .clear
        textView.font = UIFont(name: "NotoSansTC-Regular", size: 15)
        textView.textContainerInset = .zero; // fix the silly UITextView bug
        textView.textContainer.lineFragmentPadding = 0; // fix the silly UITextView bug
        textView.textColor = MYTLE
        return textView
    }()
    
    var dateLabel : UILabel = {
        var textLabel = UILabel()
        textLabel.translatesAutoresizingMaskIntoConstraints = false
        textLabel.backgroundColor = .clear
        textLabel.font = UIFont(name: "NotoSansTC-Regular", size: 15)
        textLabel.textAlignment = .right
        textLabel.textColor = MYTLE
        return textLabel
    }()
    
    lazy var imageTableView : myTableView = {
        var tableView = myTableView()
//        tableView.translatesAutoresizingMaskIntoConstraints = false
//        tableView.rowHeight = UITableView.automaticDimension
//        tableView.estimatedRowHeight = 300
        tableView.delegate = self
        tableView.dataSource = self
        tableView.register(ImageCell.self, forCellReuseIdentifier: "image")
        tableView.backgroundColor = .blue
        tableView.isScrollEnabled = false
        return tableView
    }()

        
//    var attachmentImageViews = [UIImageView]()

    
    override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) {
        super.init(style: style, reuseIdentifier : reuseIdentifier)
        self.backgroundColor = .clear

        self.contentView.addSubview(senderLabel)
        self.contentView.addSubview(messageView)
        self.contentView.addSubview(dateLabel)
        self.contentView.addSubview(imageTableView)
        
//        imageTableView.beginUpdates()
//        imageTableView.reloadData()
//        imageTableView.endUpdates()
        
    }
    
    override func prepareForReuse() {
        super.prepareForReuse()
        
    }

    
    override func layoutSubviews() {
        super .layoutSubviews()
        if let sender = sender {
            senderLabel.text = sender
        }
        if let message = message {
            messageView.text = message
        }
        if let date = date {
            dateLabel.text = date
        }
//        if imageUrls != nil {
//            self.imageTableView.reloadData()
//        }
//        for imageView in attachmentImageViews {
//            imageView.removeFromSuperview()
//        }

//        bottomConstraint?.isActive = false
        
//        if attachedImages.count > 0 {
//            attachmentImageViews.removeAll()
//            for attachedImage in attachedImages {
//                let imageView = UIImageView(image: attachedImage)
////                imageView.contentMode = .scaleAspectFit
//                imageView.isUserInteractionEnabled = true
//                imageView.translatesAutoresizingMaskIntoConstraints = false
//                attachmentImageViews.append(imageView)
//
//                let tapImageView = MyTapGestureRecognizer(target: self, action: #selector(handleTap))
//                tapImageView.imageView = imageView
//                imageView.addGestureRecognizer(tapImageView)
//
//                self.contentView.addSubview(imageView)
//            }
//            for index in 0..<attachedImages.count {
//                if (index == 0) {
//                    attachmentImageViews[index].topAnchor.constraint(equalTo: messageView.bottomAnchor, constant: 16).isActive = true
//                }
//                else {
//                    attachmentImageViews[index].topAnchor.constraint(equalTo: attachmentImageViews[index-1].bottomAnchor, constant: 5).isActive = true
//                }
//                attachmentImageViews[index].leftAnchor.constraint(equalTo: self.contentView.leftAnchor, constant: 16).isActive = true
//                attachmentImageViews[index].rightAnchor.constraint(equalTo: self.contentView.rightAnchor, constant: -16).isActive = true
//                attachmentImageViews[index].heightAnchor.constraint(equalTo: attachmentImageViews[index].widthAnchor, multiplier: (attachmentImageViews[index].image?.size.height)!/(attachmentImageViews[index].image?.size.width)!).isActive = true
//
//                if (index == attachedImages.count - 1) {
//                    bottomConstraint = attachmentImageViews[index].bottomAnchor.constraint(equalTo: self.contentView.bottomAnchor, constant: -16)
////                    attachmentImageViews[index].bottomAnchor.constraint(equalTo: self.contentView.bottomAnchor, constant: -16).isActive = true
//                    bottomConstraint?.isActive = true
//                }
//            }
//        }
//        else {
//            if (imageUrls.count > 0) {
//                bottomConstraint = messageView.bottomAnchor.constraint(equalTo: self.contentView.bottomAnchor, constant: -200)
////            messageView.bottomAnchor.constraint(equalTo: self.contentView.bottomAnchor, constant: -16).isActive = true
//            }
//            else {
//                bottomConstraint = messageView.bottomAnchor.constraint(equalTo: self.contentView.bottomAnchor, constant: -16)
//            }
//            bottomConstraint?.isActive = true
//        }
        
//        senderLabel.leftAnchor.constraint(equalTo: self.contentView.leftAnchor, constant: 16).isActive = true
//        senderLabel.topAnchor.constraint(equalTo: self.contentView.topAnchor, constant: 16).isActive = true
//        senderLabel.widthAnchor.constraint(equalToConstant: 200).isActive = true
//        senderLabel.heightAnchor.constraint(equalToConstant: 20).isActive = true
//
//        messageView.leftAnchor.constraint(equalTo: self.contentView.leftAnchor, constant: 16).isActive = true
//        messageView.topAnchor.constraint(equalTo: self.contentView.topAnchor, constant: 40).isActive = true
//        messageView.rightAnchor.constraint(equalTo: self.contentView.rightAnchor, constant: -16).isActive = true
//
//        dateLabel.topAnchor.constraint(equalTo: self.contentView.topAnchor, constant: 16).isActive = true
//        dateLabel.rightAnchor.constraint(equalTo: self.contentView.rightAnchor, constant: -20).isActive = true
//        dateLabel.widthAnchor.constraint(equalToConstant: 200).isActive = true
//        dateLabel.heightAnchor.constraint(equalToConstant: 20).isActive = true
        
//        imageTableView.leftAnchor.constraint(equalTo: self.contentView.leftAnchor, constant: 16).isActive = true
//        imageTableView.topAnchor.constraint(equalTo: messageView.bottomAnchor, constant: 16).isActive = true
//        imageTableView.rightAnchor.constraint(equalTo: self.contentView.rightAnchor, constant: -16).isActive = true
////        imageTableView.heightAnchor.constraint(equalToConstant: 300).isActive = true
//        imageTableView.bottomAnchor.constraint(equalTo: self.contentView.bottomAnchor, constant: -16).isActive = true
        
        addConstraint(NSLayoutConstraint(item: senderLabel, attribute: .top, relatedBy: .equal, toItem: self, attribute: .top, multiplier: 1.0, constant: 16))
        
        addConstraint(NSLayoutConstraint(item: senderLabel, attribute: .left, relatedBy: .equal, toItem: self, attribute: .left, multiplier: 1.0, constant: 16))

        addConstraint(NSLayoutConstraint(item: senderLabel, attribute: .width, relatedBy: NSLayoutConstraint.Relation.equal, toItem: nil, attribute: NSLayoutConstraint.Attribute.notAnAttribute, multiplier: 1, constant: 200))
       
        addConstraint(NSLayoutConstraint(item: senderLabel, attribute: NSLayoutConstraint.Attribute.height, relatedBy: NSLayoutConstraint.Relation.equal, toItem: nil, attribute: NSLayoutConstraint.Attribute.notAnAttribute, multiplier: 1, constant: 20))
        
        addConstraint(NSLayoutConstraint(item: messageView, attribute: .top, relatedBy: .equal, toItem: self, attribute: .top, multiplier: 1.0, constant: 40))

        addConstraint(NSLayoutConstraint(item: messageView, attribute: .left, relatedBy: .equal, toItem: self, attribute: .left, multiplier: 1.0, constant: 16))

        addConstraint(NSLayoutConstraint(item: messageView, attribute: .right, relatedBy: .equal, toItem: self, attribute: .right, multiplier: 1.0, constant: -16))
//
        addConstraint(NSLayoutConstraint(item: dateLabel, attribute: .top, relatedBy: .equal, toItem: self, attribute: .top, multiplier: 1.0, constant: 16))

        addConstraint(NSLayoutConstraint(item: dateLabel, attribute: .right, relatedBy: .equal, toItem: self, attribute: .right, multiplier: 1.0, constant: -20))

        addConstraint(NSLayoutConstraint(item: dateLabel, attribute: NSLayoutConstraint.Attribute.width, relatedBy: NSLayoutConstraint.Relation.equal, toItem: nil, attribute: NSLayoutConstraint.Attribute.notAnAttribute, multiplier: 1, constant: 200))
//
        addConstraint(NSLayoutConstraint(item: imageTableView, attribute: .left, relatedBy: .equal, toItem: self, attribute: .left, multiplier: 1.0, constant: 16))

        addConstraint(NSLayoutConstraint(item: imageTableView, attribute: .right, relatedBy: .equal, toItem: self, attribute: .right, multiplier: 1.0, constant: -16))

        addConstraint(NSLayoutConstraint(item: imageTableView, attribute: .top, relatedBy: .equal, toItem: messageView, attribute: .bottom, multiplier: 1.0, constant: 16))
        addConstraint(NSLayoutConstraint(item: imageTableView, attribute: .bottom, relatedBy: .equal, toItem: self, attribute: .bottom, multiplier: 1.0, constant: -16))

    
    }
    
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    @objc private func replyButtonTapped(sender: UIButton!) {

    }
//    @objc func handleTap(gestureRecognizer: MyTapGestureRecognizer) {
//        let imagesVC = ImagesViewController()
//        imagesVC.attachedImages = self.attachedImages
//        imagesVC.modalPresentationStyle = .overFullScreen
//        if let imageView = gestureRecognizer.imageView {
//            imagesVC.currentIndex = attachmentImageViews.firstIndex(of: imageView)!
//            self.viewController!.present(imagesVC, animated: true)
//        }
//    }

}


class MyTapGestureRecognizer: UITapGestureRecognizer {
    var imageView: UIImageView?
}


extension MessageCellBack: UITableViewDelegate, UITableViewDataSource {
    
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
//        return imageUrls.count
        return 1
    }
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        let cell = tableView.dequeueReusableCell(withIdentifier: "image", for: indexPath) as! ImageCell
//        cell.imageUrl = imageUrls[indexPath.row]
        cell.layoutSubviews()

//        cell.setImage()
        return cell
    }
    
    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
        return UITableView.automaticDimension
    }
    
    func tableView(_ tableView: UITableView, estimatedHeightForRowAt indexPath: IndexPath) -> CGFloat {
        return UITableView.automaticDimension
    }


}
